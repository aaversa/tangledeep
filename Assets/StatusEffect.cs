using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System.Xml;
using System.Reflection;
using System;

public sealed class StatusEffect : AbilityScript
{
    public string statusIconRef;
    public string addedByAbilityRef;
    public int addedByActorID;
    public bool showIcon;
    public bool noRemovalOrImmunity;
    public float maxDuration;
    public float curDuration;
    public bool[] runStatusTriggers;
    public bool[] durStatusTriggers;
    public bool[] consumeStatusTriggers;
    public bool isPositive;
    public bool stackMultipleEffects;
    public bool stackMultipleDurations;
    public bool refreshDurationOnCast;
    public bool directionFollowActor;
    public string ingameSprite;
    public TargetActorType ingameSpriteTarget;
    public float estimateRemainingDamage;
    public bool hasExpired;
    public bool noSpriteRotation;
    public bool spriteAlwaysVisible;
    public bool[] statusFlags;

    public bool persistentDuration;

    public List<string> destroyStatusOnRemove;
    public List<string> destroyStatusOnAdd;
    public string script_preRunConditional;
    public string script_durationModifier;
    public string script_runOnAddStatus;
    public string script_runOnRemoveStatus;

    public string commandsOnAdd;
    public string commandsOnRemove;

    public int maxStacks;

    public int energyTick;
    public int energyReq;
    public int staminaReq;
    public int staminaTick;

    public bool temp_RemovalInProgress; // No need to serialize

    public int quantity;

    public List<GameObject> spawnedOverlayRef;

    public bool sourceOfEffectIsEquippedGear;
    public bool noDurationExtensionFromStats;
    public bool excludeFromHotbarCheck; // when TRUE, this status effect is ignored by checks to make sure buffs
                                        // and toggles are generated by abilities on your hotbar.    

    public StatusEffect()
    {
        myID = globalID;
        globalID++;

        noDurationExtensionFromStats = false;
        script_runOnAddStatus = "";
        addedByAbilityRef = "";
        script_runOnRemoveStatus = "";
        temp_RemovalInProgress = false;
        noRemovalOrImmunity = false;
        sourceOfEffectIsEquippedGear = false;
        destroyStatusOnRemove = new List<string>();
        destroyStatusOnAdd = new List<string>();
        direction = Directions.NEUTRAL;
        runStatusTriggers = new bool[(int)StatusTrigger.COUNT];
        durStatusTriggers = new bool[(int)StatusTrigger.COUNT];
        consumeStatusTriggers = new bool[(int)StatusTrigger.COUNT];
        statusIconRef = "";
        showIcon = false;
        isPositive = false;
        spawnedOverlayRef = new List<GameObject>();
        quantity = 1;
        statusFlags = new bool[(int)StatusFlags.COUNT];
        curDuration = 0;
        maxDuration = 0;
        maxStacks = 99;
        hasExpired = false;
        direction = Directions.NEUTRAL;
        refreshDurationOnCast = true;
        commandsOnAdd = "";
        commandsOnRemove = "";
        numberTags = new List<string>();

        unbakedDescription = "";
        unbakedExtraDescription = "";
        unbakedShortDescription = "";
    }


    public bool AnyConsumeTriggers()
    {
        for (int i = 0; i < consumeStatusTriggers.Length; i++)
        {
            if (consumeStatusTriggers[i])
            {
                return true;
            }
        }
        return false;
    }

    public override void ConnectMissingReferencesAtLoad(bool isSub = false)
    {
        foreach (string eRef in load_effectRefsToConnect)
        {
            bool found;
            EffectScript eff = GameMasterScript.GetEffectByRef(eRef);
            if (eff == null)
            {
                Debug.Log(refName + " couldn't find " + eRef);
            }
            else
            {                

                EffectScript copyOfEff = AbilityScript.GetNewEffectFromTemplate(eff);
                AddEffectScript(copyOfEff);
            }
        }
    }

    public bool HasIngameSprite()
    {
        if (ingameSprite != null && ingameSprite != "")
        {
            return true;
        }
        return false;
    }

    public string GetLiveDescription()
    {
        string copyToParse = string.Copy(description);
        copyToParse = CustomAlgorithms.ParseLiveMergeTags(copyToParse);
        return copyToParse;
    }

    public override void ReadFromSave(XmlReader reader, Actor owner)
    {

        bool debugReadSE = false;
        string txt;
        while (reader.NodeType != XmlNodeType.EndElement)
        {
            string strValue = reader.Name.ToLowerInvariant();


            if (debugReadSE) Debug.Log("SE: " + strValue);

            switch (strValue)
            {
                case "ref":
                case "statusref":
                    refName = reader.ReadElementContentAsString();
                    StatusEffect loadTemplate = GameMasterScript.FindStatusTemplateByName(refName);
                    if (loadTemplate == null)
                    {
                        Debug.Log("Could not load template " + refName);
                    }
                    else
                    {
                        CopyStatusFromTemplate(loadTemplate);
                        //Debug.Log("Load " + refName);
                    }

                    // By default, assume all effects are originated by this actor. We can read originating actor IDs if
                    // this is not the case.
                    foreach(EffectScript eff in listEffectScripts)
                    {
                        eff.originatingActor = owner;
                        eff.selfActor = owner; //this is a safe assumption too.
                        eff.originatingActorUniqueID = owner.actorUniqueID;
                    }

                    active = true;

                    //Debug.Log("Loaded template " + refName);
                    quantity = 1; // assumed to be 1 quantity for now.
                    break;
                case "mdur":
                case "maxduration":
                    try { maxDuration = reader.ReadElementContentAsInt(); }
                    catch(Exception e)
                    {
                        maxDuration = 1;

                        if (debugReadSE) Debug.Log("Couldn't read max duration... " + maxDuration + " reader info? " + reader.Name + " : " + reader.NodeType);
                        reader.Read();
                    }
                    break;
                case "active":
                    active = reader.ReadElementContentAsBoolean();
                    break;
                case "addedbyactorid":
                    addedByActorID = reader.ReadElementContentAsInt();
                    break;
                case "addbyabil":
                    addedByAbilityRef = reader.ReadElementContentAsString();
                    break;
                case "addedbygear":
                    sourceOfEffectIsEquippedGear = reader.ReadElementContentAsBoolean();
                    break;
                case "cdur":
                case "curduration":
                    try { curDuration = reader.ReadElementContentAsInt(); }
                    catch (Exception e)
                    {
                        curDuration = 1;
                        reader.Read();
                    }
                    break;
                case "expired":
                    hasExpired = reader.ReadElementContentAsBoolean();
                    break;
                case "estimateremainingdamage":
                    txt = reader.ReadElementContentAsString();
                    estimateRemainingDamage = CustomAlgorithms.TryParseFloat(txt);
                    break;
                case "quantity":
                    quantity = reader.ReadElementContentAsInt();
                    break;
                case "dir":
                    direction = (Directions)reader.ReadElementContentAsInt();
                    break;
                case "direction":
                    direction = (Directions)Enum.Parse(typeof(Directions), reader.ReadElementContentAsString().ToUpperInvariant());
                    //Debug.Log("Direction of " + refName + " set to " + direction);
                    break;
                /* case "uniqueid":
    				uniqueID = reader.ReadElementContentAsInt();
    				break; */
                case "eff":
                case "abileffect":
                    reader.ReadStartElement();
                    int index = 0;
                    if (reader.Name == "index")
                    {
                        index = reader.ReadElementContentAsInt();
                    }
                    
                    for (int i = 0; i < listEffectScripts.Count; i++)
                    {
                        if (index == i)
                        {
                            listEffectScripts[i].originatingActorUniqueID = reader.ReadElementContentAsInt(); // This is "oaid" in the xml

                            if (listEffectScripts[i].effectType == EffectType.CHANGESTAT)
                            {
                                ChangeStatEffect cse = listEffectScripts[i] as ChangeStatEffect;
                                if (reader.Name == "accumulated")
                                {
                                    txt = reader.ReadElementContentAsString();
                                    cse.accumulatedAmount = CustomAlgorithms.TryParseFloat(txt);
                                }
                            }
                            if (listEffectScripts[i].effectType == EffectType.ALTERBATTLEDATA)
                            {
                                AlterBattleDataEffect abde = listEffectScripts[i] as AlterBattleDataEffect;
                                while (reader.NodeType != XmlNodeType.EndElement)
                                {
                                    //Debug.Log(reader.Name + " " + reader.NodeType);
                                    switch (reader.Name)
                                    {
                                        case "changedurability":
                                            abde.changeDurability = reader.ReadElementContentAsInt();
                                            break;
                                        case "accumulateddamage":
                                            txt = reader.ReadElementContentAsString();
                                            abde.accumulatedPercentAllDamage = CustomAlgorithms.TryParseFloat(txt);
                                            break;
                                        case "accumulatedmitigation":
                                            txt = reader.ReadElementContentAsString();
                                            abde.accumulatedPercentAllMitigation = CustomAlgorithms.TryParseFloat(txt);
                                            break;
                                        default:
                                            reader.Read();
                                            break;
                                    }
                                }

                            }
                            //Shep: Begin moving these load blocks to the individual classes. Today (14 sep) the only two classes that have this function
                            //are here below.
                            if (listEffectScripts[i].effectType == EffectType.SPELLSHAPE || listEffectScripts[i].effectType == EffectType.ABILITYCOSTMODIFIER)
                            {
                                while (reader.NodeType != XmlNodeType.EndElement)
                                {
                                    //processes the node, if nothing understands it, we have to reader.read anyway or 
                                    //we'll be stuck in this loop FOR EV AR
                                    if (!listEffectScripts[i].ReadNextNodeFromXML(reader))
                                    {
                                        reader.Read();
                                    }
                                }
                            }
                            break;
                        }
                    }

                    // This block is to handle discrepancies between template status effect # of effects, and saved # of effects

                    bool endOfAbilEffect = false;

                    if ((reader.NodeType == XmlNodeType.EndElement) && ((reader.Name == "abileffect") || (reader.Name == "eff")))
                    {
                        endOfAbilEffect = true;
                    }

                    while (!endOfAbilEffect)
                    {
                        reader.Read();
                        if ((reader.NodeType == XmlNodeType.EndElement) && ((reader.Name == "abileffect") || (reader.Name == "eff")))
                        {
                            endOfAbilEffect = true;
                        }
                    }


                    reader.ReadEndElement();
                    //Debug.Log("Finish SE abil effect reader " + reader.Name + " " + reader.NodeType);
                    break;
                default:
                    reader.Read();
                    break;
            }
        }

        //Debug.Log("Pre-finish: " + reader.Name + " " + reader.NodeType);

        reader.ReadEndElement();

        //Debug.Log("Finished reading status effect " + abilityName + " " + refName + " " + reader.Name + " " + reader.NodeType);
    }

    public override void WriteToSave(XmlWriter writer, int actorOwnerID, bool isDestructible = false)
    {
        writer.WriteStartElement("se");
        writer.WriteElementString("ref", refName);
        if (maxDuration > 0f)
        {
            writer.WriteElementString("mdur", maxDuration.ToString());
        }
        if (curDuration > 0f)
        {
            writer.WriteElementString("cdur", curDuration.ToString());
        }
        if (!string.IsNullOrEmpty(addedByAbilityRef))
        {
            writer.WriteElementString("addbyabil", addedByAbilityRef);
        }
        if (hasExpired)
        {
            //writer.WriteElementString("expired", hasExpired.ToString().ToLowerInvariant());
        }
        if (addedByActorID != 0)
        {
            writer.WriteElementString("addedbyactorid", addedByActorID.ToString());
        }
        if (sourceOfEffectIsEquippedGear)
        {
            writer.WriteElementString("addedbygear", "true");
        }
        if (!active && !isDestructible)
        {
            writer.WriteElementString("active", "false");
        }
        if (estimateRemainingDamage >= 0.1f || estimateRemainingDamage <= -0.1f)
        {
            writer.WriteElementString("estimateremainingdamage", estimateRemainingDamage.ToString());
        }
        if (direction != Directions.NEUTRAL)
        {
            writer.WriteElementString("dir", ((int)direction).ToString());
        }
        //writer.WriteElementString("uniqueid",uniqueID.ToString());
        if (quantity != 1)
        {
            writer.WriteElementString("quantity", quantity.ToString());
        }


        for (int i = 0; i < listEffectScripts.Count; i++)
        {
            listEffectScripts[i].WriteToSave(writer, i, actorOwnerID);
        }

        writer.WriteEndElement();
    }

    public void AddSpawnedOverlayRef(Actor act, Directions whichDir)
    {
        if (ingameSprite == null)
        {
            return;
        }

        string refToUse = ingameSprite;

        if (act.GetActorType() == ActorTypes.HERO && refToUse == "RootedEffect")
        {
            refToUse = "PlayerRootedEffect";
        }

        refToUse = CheckForChampionSkullSpecialCase(act, refToUse);

        GameObject go = act.GetObject();
        if (!spawnedOverlayRef.Contains(go))
        {
            GameObject overlay = null;

            bool success = true;

            try { overlay = CombatManagerScript.SpawnChildSprite(refToUse, act, whichDir, !noSpriteRotation); }
            catch (Exception e)
            {
                Debug.Log("Failed to spawn overlay: " + e);
                Debug.Log("Overlay: " + refToUse);
                success = false;
            }

            if (success)
            {
                if (overlay != null)
                {
                    // Special case for "aura" type effects. These are ALWAYS on, and not intermittent.
                    if (refToUse.Contains("Aura"))
                    {
                        spawnedOverlayRef.Add(overlay);
                        overlay.GetComponent<SpriteEffect>().parentAbility = this;
                        //if (act.GetActorType() == ActorTypes.HERO)
                        {
                            if (act.auraObject != null && act.auraObject.activeSelf && act.auraObject != overlay)
                            {
                                SpriteEffect se = act.auraObject.GetComponent<SpriteEffect>();
                                if (se != null)
                                {
                                    GameMasterScript.ReturnToStack(act.auraObject, se.refName);
                                }
                                else
                                {
                                    GameMasterScript.ReturnToStack(act.auraObject, act.auraObject.name.Replace("(Clone)", String.Empty));
                                }                                                                
                            }
                            act.auraObject = overlay;
                        }
                        return;
                    }


                    spawnedOverlayRef.Add(overlay);
                    act.AddOverlay(overlay, spriteAlwaysVisible);
                    overlay.GetComponent<SpriteEffect>().parentAbility = this;

                    //if (Debug.isDebugBuild) Debug.Log("Created object overlay " + overlay.gameObject.name + " for status with duration " + curDuration + " max of " + maxDuration);
                }
                else
                {
                    //Debug.Log(act.actorRefName + " could not get overlay " + refToUse);
                }
            }
        }
    }

    string CheckForChampionSkullSpecialCase(Actor act, string refToUse)
    {
        if (refName == "championmonster" || refToUse.ToLowerInvariant() == "championskull")
        {
            Monster mn = act as Monster;
            switch (mn.championMods.Count)
            {
                case 0:
                case 1:
                    refToUse = "ChampionSkull1";
                    break;
                case 2:
                    refToUse = "ChampionSkull2";
                    break;
                case 3:
                    refToUse = "ChampionSkull3";
                    break;
                case 4:
                default: // 4 mods, 5 mods, etc
                    refToUse = "ChampionSkull4";
                    break;
            }
            if (mn.ReadActorData("godchampion") == 1)
            {
                refToUse = "ChampionSkull5";
            }
        }

        return refToUse;
    }

    public void RunCommandsOnAdd(Fighter owner)
    {
        string[] parsed = commandsOnAdd.Split(',');
        for (int i = 0; i < parsed.Length; i++)
        {
            string[] subParsed = parsed[i].Split(':');
            // command,value
            switch (subParsed[0])
            {
                case "aura":
                    owner.CreateNewElementalAura((DamageTypes)Enum.Parse(typeof(DamageTypes), subParsed[1].ToUpperInvariant()));
                    break;
                case "specialfunction":

                    Func<SpecialEffect, List<Actor>, EffectResultPayload> dFunc;

                    if (SpecialEffectFunctions.dictDelegates.TryGetValue(subParsed[1], out dFunc))
                    {
                        EffectResultPayload erp = dFunc(null, new List<Actor>() { owner });
                    }
                    else
                    {
                        MethodInfo runscript = CustomAlgorithms.TryGetMethod(typeof(SpecialEffectFunctions), subParsed[1]);
                        if (runStatusTriggers != null)
                        {
                            object[] paramList = new object[2];
                            paramList[0] = null;
                            List<Actor> lOwner = new List<Actor>();
                            lOwner.Add(owner);
                            paramList[1] = lOwner;
                            object returnObj = runscript.Invoke(null, paramList);
                        }
                    }

                    break;
            }
        }
    }

    public void RunCommandsOnRemove(Fighter owner)
    {
        string[] parsed = commandsOnRemove.Split(',');
        for (int i = 0; i < parsed.Length; i++)
        {
            string[] subParsed = parsed[i].Split(':');
            // command,value
            switch (subParsed[0])
            {
                case "destroyaura":
                    if (owner.elemAuraObject != null && owner.elemAuraObject.gameObject.activeSelf)
                    {
                        owner.elemAuraObject.StopAndDie();
                    }
                    break;
            }
        }
    }

    public void CleanupAfterRemoval()
    {
        //if (Debug.isDebugBuild) Debug.Log(refName + " status expiry, overlay count: " + spawnedOverlayRef.Count);
        foreach (GameObject go in spawnedOverlayRef)
        {
            // Need to check if GO is destroyed.
            if (go == null)
            {
                //if (Debug.isDebugBuild) Debug.Log("No game object.");
                continue;
            }
            SpriteEffect se = go.GetComponent<SpriteEffect>();
            if (se.attachedActor != null)
            {
                //if (Debug.isDebugBuild) Debug.Log("Removed overlay.");
                se.attachedActor.RemoveOverlay(go);
            }
            SpriteEffectSystem ses = go.GetComponent<SpriteEffectSystem>();
            if (ses != null)
            {
                foreach (Transform child in ses.gameObject.transform)
                {
                    GameMasterScript.ReturnToStack(child.gameObject, child.GetComponent<SpriteEffect>().refName);
                }
            }
            bool debugStackReturn = false;

            /* if (Debug.isDebugBuild)
            {
                Debug.Log("Returning " + go.name + " to stack.");
                debugStackReturn = true;
            } */

            GameMasterScript.ReturnToStack(go, se.refName, null, true, debugStackReturn);
        }
        spawnedOverlayRef.Clear();
    }

    public bool CheckRunTriggerOn(StatusTrigger st)
    {
        return runStatusTriggers[(int)st];
    }

    public bool CheckDurTriggerOn(StatusTrigger st)
    {
        return durStatusTriggers[(int)st];
    }

    public bool CheckConsumeTriggerOn(StatusTrigger st)
    {
        return consumeStatusTriggers[(int)st];
    }

    public void ExtendDuration(int extendAmount, int ceiling)
    {
        curDuration += extendAmount;
        maxDuration += extendAmount;
        if (curDuration > ceiling) curDuration = ceiling;
        if (maxDuration > ceiling) maxDuration = ceiling;
    }

    public void ConvertDamage(DamageTypes dt)
    {
        if ((listEffectScripts == null) || (listEffectScripts.Count == 0)) return;
        foreach (EffectScript eff in listEffectScripts)
        {
            if (eff.effectType == EffectType.DAMAGE)
            {
                DamageEffect de = eff as DamageEffect;
                de.damType = dt;
            }
        }
    }

    public void RunStatus(StatusTrigger trigger, Actor actorOwner)
    {
        // Do not run status if actor is dead.
        if (trigger != StatusTrigger.DESTROYED && actorOwner.IsFighter())
        {
            Fighter ft = actorOwner as Fighter;
            if (!ft.myStats.IsAlive())
            {
                return;
            }
        }

        estimateRemainingDamage = 0f;

        HeroPC hero = GameMasterScript.heroPCActor;

        if (refName == "status_escapedungeon")
        {
            hero.SetActorData("sideareawarp", 0);
            
            if (hero.GetActorMap().IsTownMap())
            {
                return;
            }
            if (curDuration <= 0)
            {
                hero.SetActorData("using_escape_portal", 1);

                if (UIManagerScript.currentConversation != null && UIManagerScript.currentConversation.refName == "restfire")
                {
                    UIManagerScript.CloseDialogBox();
                }

                UIManagerScript.PlayCursorSound("Mirage");

                GameObject tpUp = CombatManagerScript.GenerateSpecificEffectAnimation(GameMasterScript.heroPCActor.GetPos(), "TeleportUpSilent", null, false);
                tpUp.transform.SetParent(GameMasterScript.heroPCActor.GetObject().transform); // Make sure teleport effect is constantly ON Mirai
                tpUp.transform.localPosition = Vector3.zero;

                if (MapMasterScript.activeMap.IsItemWorld())
                {
                    GameMasterScript.heroPCActor.portalLocationFromItemWorld = GameMasterScript.heroPCActor.GetPos();
                    TravelManager.TravelMaps(MapMasterScript.singletonMMS.townMap2, null, true);
                }
                else
                {
                    TravelManager.TravelMaps(MapMasterScript.singletonMMS.townMap, null, true);
                }

            }
            return;
        }
        else if (refName == "status_thunderinglion") // Hardcoded thundering lion charges
        {
            if (hero.myStats.CheckStatusQuantity("status_tlioncharge") == 3)
            {
                return;
            }
        }

        if (spiritsRequired > 0)
        {
            for (int i = 0; i < spiritsRequired; i++)
            {
                GameMasterScript.heroPCActor.myStats.RemoveStatusByRef("spiritcollected");
            }
        }

        if (UnityEngine.Random.Range(0, 1f) <= 0.05f && refName == "status_ppexplode")
        {
            GameLogScript.LogWriteStringRef("log_easteregg_kenshiro");
        }

        if (refName == "status_mmfairy")
        {
            if (UnityEngine.Random.Range(0, 1f) <= 0.2f)
            {
                List<AbilityScript> tickPossible = new List<AbilityScript>();
                foreach (AbilityScript abil in GameMasterScript.heroPCActor.myAbilities.GetAbilityList())
                {
                    if (abil.passiveAbility)
                    {
                        continue;
                    }
                    if (abil.GetCurCooldownTurns() > 0)
                    {
                        tickPossible.Add(abil);
                    }
                }
                if (tickPossible.Count > 0)
                {
                    AbilityScript abil = tickPossible[UnityEngine.Random.Range(0, tickPossible.Count)];
                    abil.ChangeCurrentCooldown(-1);
                    UIManagerScript.RefreshHotbarSkills();
                }
            }
            return;
        }

        if (listEffectScripts.Count == 0) return;

        for (int t = 0; t < listEffectScripts.Count; t++)
        {         
            EffectScript eff = listEffectScripts[t];

            if (!eff.noClearPositionsOnRun)
            {
                eff.positions.Clear(); // Should we always do this?
            }

            bool runEffect = true;
            if (hasConditions)
            {
                foreach (EffectConditional ec in conditions)
                {
                    if (ec.index == t)
                    {
                        runEffect = false;
                        switch (ec.ec)
                        {
                            case EffectConditionalEnums.STATUSREMOVED:
                                foreach (Actor act in EffectScript.actorsAffectedByAbility)
                                {
                                    if (act.IsFighter())
                                    {
                                        Fighter ft = act as Fighter;
                                        if (ft.myStats.CountStatusesRemovedSinceLastTurn() > 0)
                                        {
                                            runEffect = true;
                                        }
                                    }
                                }
                                break;
                            case EffectConditionalEnums.ORIGDAMAGETAKEN: // Generalize this.
                                if (GameMasterScript.heroPCActor.flagData[(int)ActorFlags.TRACKDAMAGE] >= (GameMasterScript.heroPCActor.myStats.GetStat(StatTypes.HEALTH, StatDataTypes.MAX) * 0.1f))
                                {
                                    runEffect = true;
                                    GameMasterScript.heroPCActor.clearTrackDamageFlagAtEndOfTurn = true;
                                    //GameMasterScript.heroPCActor.SetFlag(ActorFlags.TRACKDAMAGE, false);
                                }
                                break;
                        }
                    }
                }
            }
            if (!runEffect) continue;

            //Debug.Log(eff.effectName + " " + eff.effectRefName + " run from status " + refName);
            eff.selfActor = actorOwner;
            if (eff.originatingActor == null)
            {
                eff.originatingActor = actorOwner;
            }

            if (CheckAbilityTag(AbilityTags.DRAGONSOUL))
            {
                DragonLimitBreaks.AddTargetsForDragonBreak(this, eff, actorOwner);
            }

            eff.DoEffect();
            if (eff.effectType == EffectType.DAMAGE)
            {
                // Some kind of poison / bleed effect. Extrapolate remaining damage.
                DamageEffect de = eff as DamageEffect;
                estimateRemainingDamage += de.lastDamageAmount * curDuration;
                //Debug.Log("GUESS: Remaining damage for " + eff.effectName + " " + abilityName + " is " + estimateRemainingDamage + " " + de.lastDamageAmount + " " + curDuration);
            }
        }
    }

    public void RefreshDuration()
    {
        curDuration = maxDuration;
    }

    public bool TickStatus()
    {
        curDuration--;
        if (curDuration == 0)
        {
            return true;
        }
        else
        {
            return false;
        }
        // Returns EXPIRED or not
    }

    public void SetSubEffectsToOrigActor(Actor act)
    {
        foreach(EffectScript eff in listEffectScripts)
        {
            eff.originatingActor = act;
            eff.originatingActorUniqueID = act.actorUniqueID;
        }
    }

    public void CopyStatusFromTemplate(StatusEffect template)
    {
        sfxOverride = template.sfxOverride;
        script_runOnRemoveStatus = template.script_runOnRemoveStatus;
        excludeFromHotbarCheck = template.excludeFromHotbarCheck;
        noDurationExtensionFromStats = template.noDurationExtensionFromStats;
        script_runOnAddStatus = template.script_runOnAddStatus;
        commandsOnAdd = template.commandsOnAdd;
        commandsOnRemove = template.commandsOnRemove;
        persistentDuration = template.persistentDuration;
        noRemovalOrImmunity = template.noRemovalOrImmunity;
        directionFollowActor = template.directionFollowActor;
        spriteAlwaysVisible = template.spriteAlwaysVisible;
        noSpriteRotation = template.noSpriteRotation;
        combatLogText = template.combatLogText;
        energyTick = template.energyTick;
        energyReq = template.energyReq;
        staminaReq = template.staminaReq;
        staminaTick = template.staminaTick;
        combatOnly = template.combatOnly;
        direction = template.direction;
        abilityName = template.abilityName;
        //Debug.Log("Copying status effect " + template.abilityName + " " + template.refName);
        refName = template.refName;
        description = template.description;
        showIcon = template.showIcon;
        statusIconRef = template.statusIconRef;
        maxDuration = template.maxDuration;
        curDuration = template.maxDuration;
        isPositive = template.isPositive;
        maxStacks = template.maxStacks;
        stackMultipleEffects = template.stackMultipleEffects;
        stackMultipleDurations = template.stackMultipleDurations;
        refreshDurationOnCast = template.refreshDurationOnCast;
        ingameSprite = template.ingameSprite;
        ingameSpriteTarget = template.ingameSpriteTarget;
        reqWeaponType = template.reqWeaponType;
        spiritsRequired = template.spiritsRequired;
        script_preRunConditional = template.script_preRunConditional;
        script_durationModifier = template.script_durationModifier;
        destroyStatusOnAdd = template.destroyStatusOnAdd;
        destroyStatusOnRemove = template.destroyStatusOnRemove;

        if (template.hasConditions)
        {
            conditions = new List<EffectConditional>();
            hasConditions = true;
            foreach (EffectConditional tec in template.conditions)
            {
                EffectConditional ec = new EffectConditional();
                ec.ec = tec.ec;
                ec.index = tec.index;
                conditions.Add(ec);
            }
        }
        int iFlagMax = Math.Min(statusFlags.Length, template.statusFlags.Length);
        for (int i = 0; i < iFlagMax; i++)
        {
            statusFlags[i] = template.statusFlags[i];
        }
        foreach (EffectScript eff in template.listEffectScripts)
        {
            EffectScript newEff = AbilityScript.GetNewEffectFromTemplate(eff);
            newEff.parentAbility = template;
            AddEffectScript(newEff);
        }

        iFlagMax = Math.Min(runStatusTriggers.Length, template.runStatusTriggers.Length);
        for (int i = 0; i < iFlagMax; i++)
        {
            runStatusTriggers[i] = template.runStatusTriggers[i];
            durStatusTriggers[i] = template.durStatusTriggers[i];
            consumeStatusTriggers[i] = template.consumeStatusTriggers[i];
        }

        CopyAbilityTags(template);

        foreach(string tag in template.numberTags)
        {
            numberTags.Add(tag);
        }

        /*
        for (int c = 0; c < (int)AbilityTags.COUNT; c++)
        {
            myAbilityTags[c] = template.myAbilityTags[c];           
        }
        */

        //Shep: Scripts for events
        script_AttackBlock = template.script_AttackBlock;
        script_FighterBelowHalfHealth = template.script_FighterBelowHalfHealth;
        script_FighterBelowQuarterHealth = template.script_FighterBelowQuarterHealth;
        script_FighterBelow33Health = template.script_FighterBelow33Health;
        script_FighterBelow60Health = template.script_FighterBelow60Health;
        script_SpecialTargeting = template.script_SpecialTargeting;

    }
}
